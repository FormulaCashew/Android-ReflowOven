\documentclass[11pt, a4paper, oneside]{report}

% ==========================================
% PAQUETES Y CONFIGURACIÓN
% ==========================================
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-tabla]{babel}
\usepackage[T1]{fontenc}
\usepackage{helvet} % Fuente más moderna (Helvetica)
\renewcommand{\familydefault}{\sfdefault}

\usepackage{geometry}
\geometry{top=3cm, bottom=3cm, left=3cm, right=2.5cm}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tcolorbox} % Para cajas de texto profesionales
\usepackage{enumitem}
\usepackage{booktabs} % Tablas profesionales
\usepackage{longtable}

% Definición de Colores Corporativos/Técnicos
\definecolor{primaryBlue}{RGB}{0, 51, 102}
\definecolor{accentTeal}{RGB}{0, 128, 128}
\definecolor{lightGray}{RGB}{245, 245, 245}
\definecolor{codeBackground}{RGB}{250, 250, 250}
\definecolor{callStackColor}{RGB}{240, 248, 255}

% Configuración de Hipervínculos
\hypersetup{
    colorlinks=true,
    linkcolor=primaryBlue,
    filecolor=magenta,      
    urlcolor=accentTeal,
    pdftitle={Documentación Técnica - Reflow Oven Controller},
}

% Configuración de Encabezados y Pies de Página
\pagestyle{fancy}
\fancyhf{}
\lhead{\textcolor{gray}{\small Reflow Oven Controller - Android Architecture}}
\rhead{\textcolor{gray}{\small Versión 1.0}}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Configuración de Estilos de Código (Kotlin)
\lstdefinestyle{kotlinStyle}{
    language=Java, % Kotlin se basa en JVM, Java es buena aproximación para highlight
    backgroundcolor=\color{codeBackground},   
    commentstyle=\color{gray}\itshape,
    keywordstyle=\color{primaryBlue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{accentTeal},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=leftline,
    rulecolor=\color{accentTeal},
    xleftmargin=10pt,
}
\lstset{style=kotlinStyle}

% Formato de Títulos
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries\color{primaryBlue}}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
  {\normalfont\Large\bfseries\color{primaryBlue}}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{accentTeal}}{\thesubsection}{1em}{}

% Definición de Cajas para "Lógica de Llamadas"
\newtcolorbox{calltrace}[1]{
  colback=callStackColor,
  colframe=primaryBlue,
  title=\textbf{Traza de Ejecución: #1},
  fonttitle=\bfseries,
  boxrule=0.5mm,
  sharp corners=south,
  rounded corners=north
}

% ==========================================
% DOCUMENTO
% ==========================================

\begin{document}

% --- PORTADA ---
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge \textbf{\textcolor{primaryBlue}{SISTEMA DE CONTROL PARA HORNO DE REFLUJO}}}\\[0.5cm]
    {\Large \textit{Documentación Técnica de Software Android}}\\[2cm]
    
    \textbf{Arquitectura:} MVVM (Model-View-ViewModel)\\
    \textbf{Lenguaje:} Kotlin / Jetpack Compose\\
    \textbf{Protocolo:} TCP Sockets (Raw ASCII)\\[3cm]
    
    \vfill
    
    \textbf{Departamento de Ingeniería en Automatización}\\
    \today
    
\end{titlepage}

% --- INDICE ---
\tableofcontents
\newpage

% ==========================================
% CAPÍTULO 1
% ==========================================
\chapter{Visión General del Sistema}

\section{Introducción}
El presente documento detalla la arquitectura de software, la dinámica de ejecución y los protocolos de comunicación de la aplicación móvil "Reflow Oven Controller". Este sistema permite la supervisión remota y el control de lazo cerrado de un horno de soldadura mediante una interfaz gráfica reactiva y comunicación de red en tiempo real.

\section{Alcance Técnico}
El software ha sido diseñado bajo los principios de \textit{Clean Architecture} simplificada, implementando el patrón \textbf{MVVM}. Sus responsabilidades principales incluyen:
\begin{enumerate}
    \item \textbf{Gestión de Conectividad:} Establecimiento y mantenimiento de sockets TCP persistentes.
    \item \textbf{Visualización de Datos:} Renderizado de gráficos de temperatura vs. tiempo a 60 FPS.
    \item \textbf{Inyección de Perfiles:} Serialización y transmisión de etapas de soldadura (Soak, Reflow).
    \item \textbf{Concurrencia:} Manejo de hilos en segundo plano para operaciones de E/S.
\end{enumerate}

% ==========================================
% CAPÍTULO 2
% ==========================================
\chapter{Arquitectura de Software}

La aplicación se estructura en tres capas lógicas claramente diferenciadas para garantizar la escalabilidad y testabilidad.

\section{Capa de Presentación (UI Layer)}
Implementada utilizando \textbf{Jetpack Compose}. Esta capa es puramente reactiva; no contiene lógica de negocio, solo lógica de renderizado basada en estados.
\begin{itemize}
    \item \texttt{MainActivity.kt}: Punto de entrada del sistema Android. Configura el tema y el contenedor de superficie.
    \item \texttt{DashboardScreen.kt}: Composable principal. Observa los flujos (\textit{Flows}) del ViewModel y redibuja la interfaz cuando los datos cambian.
    \item \texttt{OvenChart.kt}: Wrapper de interoperabilidad que incrusta una vista de Android clásica (\texttt{MPAndroidChart}) dentro de la jerarquía de Compose.
\end{itemize}

\section{Capa de Lógica de Negocio (ViewModel Layer)}
\texttt{MainViewModel.kt} actúa como el cerebro de la aplicación.
\begin{itemize}
    \item Transforma los datos crudos del repositorio en estados consumibles por la UI (\texttt{StateFlow}).
    \item Gestiona el ciclo de vida de las corrutinas (\texttt{viewModelScope}), asegurando que no haya fugas de memoria si la vista se destruye.
    \item Contiene la lógica de limitación del historial gráfico (buffer circular de 120 puntos).
\end{itemize}

\section{Capa de Datos (Data Layer)}
Responsable de la comunicación con el mundo exterior.
\begin{itemize}
    \item \texttt{ReflowOvenRepository.kt}: Patrón repositorio que abstrae la fuente de datos.
    \item \texttt{WiFiService.kt}: Implementación de bajo nivel de \texttt{CommunicationService}. Maneja los \texttt{Sockets}, \texttt{PrintWriters} y \texttt{Scanners}.
\end{itemize}

% ==========================================
% CAPÍTULO 3
% ==========================================
\chapter{Dinámica de Ejecución y Trazabilidad}

Esta sección es el núcleo técnico del documento. Se desglosa la jerarquía de llamadas funcionales para los procesos críticos del sistema.

\section{Traza 1: Ciclo de Monitoreo (Polling Loop)}
Este proceso es responsable de mantener la gráfica y los textos de estado actualizados en tiempo real.

\begin{calltrace}{Actualización de Estado del Horno}
\textbf{Contexto:} \texttt{MainViewModel} inicia una corrutina tras una conexión exitosa.

\begin{enumerate}
    \item \texttt{\textbf{MainViewModel}}:
    \begin{itemize}
        \item Llama a \texttt{repository.getOvenState()}.
        \item Inicia bloque \texttt{collect} (observador) sobre el flujo retornado.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{ReflowOvenRepository}}:
    \begin{itemize}
        \item Redirige la llamada a \texttt{communicationService.getOvenState()}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{WiFiService}} (Hilo: \texttt{Dispatchers.IO}):
    \begin{itemize}
        \item Entra en bucle \texttt{while (isConnected)}.
        \item \texttt{sendCommand("STATUS?\textbackslash n")}: Escribe en el Socket.
        \item \texttt{reader.nextLine()}: \textbf{Bloqueo} esperando respuesta del hardware.
        \item \textit{Parsing}: Divide la cadena recibida por delimitadores ``;''.
        \item Instancia \texttt{OvenState(temp, target, stage...)}.
        \item \texttt{emit(ovenState)}: Envía el objeto a través del flujo.
        \item \texttt{delay(1000)}: Espera no bloqueante antes del siguiente ciclo.
    \end{itemize}
    
    \item $\leftarrow$ \textit{Retorno a} \texttt{\textbf{MainViewModel}} (Hilo: \texttt{Main}):
    \begin{itemize}
        \item Recibe \texttt{OvenState}.
        \item Actualiza \texttt{\_ovenState.value} $\rightarrow$ Dispara recomposición de Textos.
        \item Llama a función interna \texttt{addGraphPoint(temp)}.
        \begin{itemize}
            \item Añade punto a \texttt{\_tempHistory}.
            \item Si \texttt{size > 120}, elimina el índice 0 (FIFO).
            \item Actualiza \texttt{\_tempHistory.value}.
        \end{itemize}
    \end{itemize}
    
    \item $\leftarrow$ \textit{Reacción en} \texttt{\textbf{DashboardScreen}}:
    \begin{itemize}
        \item \texttt{collectAsState} detecta cambio en \texttt{tempHistory}.
        \item Pasa los nuevos datos al composable \texttt{OvenChart}.
    \end{itemize}

    \item $\hookrightarrow$ \texttt{\textbf{OvenChart}}:
    \begin{itemize}
        \item Bloque \texttt{update}: Recibe los puntos nuevos.
        \item Actualiza el \texttt{LineDataSet} de la librería MPAndroidChart.
        \item Llama a \texttt{chart.notifyDataSetChanged()} e \texttt{invalidate()}.
    \end{itemize}
\end{enumerate}
\end{calltrace}

\section{Traza 2: Inyección de Perfil (Comando START)}
Proceso desencadenado cuando el usuario selecciona un perfil y pulsa "Start".

\begin{calltrace}{Envío de Perfil de Soldadura}
\textbf{Contexto:} Interacción de usuario en \texttt{DashboardScreen}.

\begin{enumerate}
    \item \texttt{\textbf{DashboardScreen}}:
    \begin{itemize}
        \item Callback \texttt{onProfileSelected}.
        \item Llama a \texttt{viewModel.startOven(reflowProfile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{MainViewModel}}:
    \begin{itemize}
        \item \texttt{launch}: Inicia nueva corrutina.
        \item Limpieza: \texttt{\_tempHistory.value = emptyList()}.
        \item Reinicio: \texttt{timeIndex = 0f}.
        \item Llama a \texttt{repository.startOven(profile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{ReflowOvenRepository}}:
    \begin{itemize}
        \item Delega a \texttt{communicationService.startOven(profile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{WiFiService}} (Hilo: \texttt{Dispatchers.IO}):
    \begin{itemize}
        \item \textbf{Serialización}: Transforma el objeto \texttt{ReflowProfile} en cadena.
        \item Construye string: \texttt{"START;" + stage.temp + ";" + stage.time ...}
        \item Llama a \texttt{sendCommand(string)}.
        \begin{itemize}
            \item \texttt{writer.print(command)}.
            \item \texttt{writer.flush()}: Fuerza el envío del paquete TCP inmediatamente.
        \end{itemize}
    \end{itemize}
\end{enumerate}
\end{calltrace}

% ==========================================
% CAPÍTULO 4
% ==========================================
\chapter{Especificación del Protocolo de Comunicación}

El sistema utiliza un protocolo basado en texto ASCII sobre TCP/IP. La aplicación actúa como Cliente TCP y el Horno como Servidor TCP.

\section{Formato de Comandos (Cliente $\rightarrow$ Horno)}
Los comandos finalizan con un carácter de nueva línea (\texttt{\textbackslash n}).

\begin{longtable}{@{}p{4cm}p{10cm}@{}}
\toprule
\textbf{Comando} & \textbf{Descripción y Estructura} \\ \midrule
\endhead

\texttt{STATUS?} & 
Solicita el estado actual. No requiere parámetros. \\ \hline

\texttt{STOP} & 
Detiene el proceso de calentamiento inmediatamente. \\ \hline

\texttt{START;<Stages>} & 
Inicia el horno con un perfil específico. La estructura de \texttt{<Stages>} es una lista serializada de temperatura y duración. \newline
\textit{Ejemplo:} \texttt{START;Soak;150;90;Reflow;245;30} \\ \hline

\texttt{PROFILE;<Stages>} & 
Carga un perfil en memoria sin iniciar el proceso inmediatamente. Sigue la misma serialización que START. \\ 
\bottomrule
\caption{Tabla de Comandos de Control}
\end{longtable}

\section{Formato de Respuesta (Horno $\rightarrow$ Cliente)}
El horno responde al comando \texttt{STATUS?} con una cadena delimitada por punto y coma (;).

\begin{tcolorbox}[colback=codeBackground, title=Estructura de Trama STATUS]
\texttt{STATUS;CurrentTemp;TargetTemp;StageName;TimeElapsed}
\end{tcolorbox}

\textbf{Mapeo de Datos en \texttt{WiFiService.kt}:}
\begin{itemize}
    \item \texttt{parts[0]} $\rightarrow$ Cabecera ("STATUS")
    \item \texttt{parts[1]} $\rightarrow$ \texttt{currentTemperature} (Float)
    \item \texttt{parts[2]} $\rightarrow$ \texttt{targetTemperature} (Float)
    \item \texttt{parts[3]} $\rightarrow$ \texttt{stage} (String, e.g., "Soak")
    \item \texttt{parts[4]} $\rightarrow$ \texttt{timeElapsed} (Long)
\end{itemize}
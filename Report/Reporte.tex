\documentclass[11pt, a4paper, oneside]{report}

% ==========================================
% PAQUETES Y CONFIGURACIÓN
% ==========================================
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-tabla]{babel}
\usepackage[T1]{fontenc}
\usepackage{helvet} % Fuente más moderna (Helvetica)
\renewcommand{\familydefault}{\sfdefault}

\usepackage{geometry}
\geometry{top=3cm, bottom=3cm, left=3cm, right=2.5cm}

\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{titlesec}
\usepackage{tcolorbox} % Para cajas de texto profesionales
\usepackage{enumitem}
\usepackage{booktabs} % Tablas profesionales
\usepackage{longtable}

% Definición de Colores Corporativos/Técnicos
\definecolor{primaryBlue}{RGB}{0, 51, 102}
\definecolor{accentTeal}{RGB}{0, 128, 128}
\definecolor{lightGray}{RGB}{245, 245, 245}
\definecolor{codeBackground}{RGB}{250, 250, 250}
\definecolor{callStackColor}{RGB}{240, 248, 255}

% Configuración de Hipervínculos
\hypersetup{
    colorlinks=true,
    linkcolor=primaryBlue,
    filecolor=magenta,      
    urlcolor=accentTeal,
    pdftitle={Documentación Técnica - Reflow Oven Controller},
}

% Configuración de Encabezados y Pies de Página
\pagestyle{fancy}
\fancyhf{}
\lhead{\textcolor{gray}{\small Reflow Oven Controller - Android Architecture}}
\rhead{\textcolor{gray}{\small Versión 1.0}}
\cfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

% Configuración de Estilos de Código (Kotlin)
\lstdefinestyle{kotlinStyle}{
    language=Java, % Kotlin se basa en JVM, Java es buena aproximación para highlight
    backgroundcolor=\color{codeBackground},   
    commentstyle=\color{gray}\itshape,
    keywordstyle=\color{primaryBlue}\bfseries,
    numberstyle=\tiny\color{gray},
    stringstyle=\color{accentTeal},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    frame=leftline,
    rulecolor=\color{accentTeal},
    xleftmargin=10pt,
}
\lstset{style=kotlinStyle}

% Formato de Títulos
\titleformat{\chapter}[display]
  {\normalfont\huge\bfseries\color{primaryBlue}}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titleformat{\section}
  {\normalfont\Large\bfseries\color{primaryBlue}}{\thesection}{1em}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\color{accentTeal}}{\thesubsection}{1em}{}

% Definición de Cajas para "Lógica de Llamadas"
\newtcolorbox{calltrace}[1]{
  colback=callStackColor,
  colframe=primaryBlue,
  title=\textbf{Traza de Ejecución: #1},
  fonttitle=\bfseries,
  boxrule=0.5mm,
  sharp corners=south,
  rounded corners=north
}

% ==========================================
% DOCUMENTO
% ==========================================

\begin{document}

% --- PORTADA ---
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\Huge \textbf{\textcolor{primaryBlue}{SISTEMA DE CONTROL PARA HORNO DE REFLUJO}}}\\[0.5cm]
    {\Large \textit{Documentación Técnica de Software Android}}\\[2cm]
    
    \textbf{Arquitectura:} MVVM (Model-View-ViewModel)\\
    \textbf{Lenguaje:} Kotlin / Jetpack Compose\\
    \textbf{Protocolo:} TCP Sockets (Raw ASCII)\\[3cm]
    
    \vfill
    
    \textbf{Departamento de Ingeniería en Automatización}\\
    \today
    
\end{titlepage}

% --- INDICE ---
\tableofcontents
\newpage

% ==========================================
% CAPÍTULO 1
% ==========================================
\chapter{Visión General del Sistema}

\section{Introducción}
El presente documento detalla la arquitectura de software, la dinámica de ejecución y los protocolos de comunicación de la aplicación móvil "Reflow Oven Controller". Este sistema permite la supervisión remota y el control de lazo cerrado de un horno de soldadura mediante una interfaz gráfica reactiva y comunicación de red en tiempo real.

\section{Alcance Técnico}
El software ha sido diseñado bajo los principios de \textit{Clean Architecture} simplificada, implementando el patrón \textbf{MVVM}. Sus responsabilidades principales incluyen:
\begin{enumerate}
    \item \textbf{Gestión de Conectividad:} Establecimiento y mantenimiento de sockets TCP persistentes.
    \item \textbf{Visualización de Datos:} Renderizado de gráficos de temperatura vs. tiempo a 60 FPS.
    \item \textbf{Inyección de Perfiles:} Serialización y transmisión de etapas de soldadura (Soak, Reflow).
    \item \textbf{Concurrencia:} Manejo de hilos en segundo plano para operaciones de E/S.
\end{enumerate}

% ==========================================
% CAPÍTULO 2
% ==========================================
\chapter{Arquitectura de Software}

La aplicación se estructura en tres capas lógicas claramente diferenciadas para garantizar la escalabilidad y testabilidad.

\section{Capa de Presentación (UI Layer)}
Implementada utilizando \textbf{Jetpack Compose}. Esta capa es puramente reactiva; no contiene lógica de negocio, solo lógica de renderizado basada en estados.
\begin{itemize}
    \item \texttt{MainActivity.kt}: Punto de entrada del sistema Android. Configura el tema y el contenedor de superficie.
    \item \texttt{DashboardScreen.kt}: Composable principal. Observa los flujos (\textit{Flows}) del ViewModel y redibuja la interfaz cuando los datos cambian.
    \item \texttt{OvenChart.kt}: Wrapper de interoperabilidad que incrusta una vista de Android clásica (\texttt{MPAndroidChart}) dentro de la jerarquía de Compose.
\end{itemize}

\section{Capa de Lógica de Negocio (ViewModel Layer)}
\texttt{MainViewModel.kt} actúa como el cerebro de la aplicación.
\begin{itemize}
    \item Transforma los datos crudos del repositorio en estados consumibles por la UI (\texttt{StateFlow}).
    \item Gestiona el ciclo de vida de las corrutinas (\texttt{viewModelScope}), asegurando que no haya fugas de memoria si la vista se destruye.
    \item Contiene la lógica de limitación del historial gráfico (buffer circular de 120 puntos).
\end{itemize}

\section{Capa de Datos (Data Layer)}
Responsable de la comunicación con el mundo exterior.
\begin{itemize}
    \item \texttt{ReflowOvenRepository.kt}: Patrón repositorio que abstrae la fuente de datos.
    \item \texttt{WiFiService.kt}: Implementación de bajo nivel de \texttt{CommunicationService}. Maneja los \texttt{Sockets}, \texttt{PrintWriters} y \texttt{Scanners}.
\end{itemize}

% ==========================================
% CAPÍTULO 3
% ==========================================
\chapter{Dinámica de Ejecución y Trazabilidad}

Esta sección es el núcleo técnico del documento. Se desglosa la jerarquía de llamadas funcionales para los procesos críticos del sistema.

\section{Traza 1: Ciclo de Monitoreo (Polling Loop)}
Este proceso es responsable de mantener la gráfica y los textos de estado actualizados en tiempo real.

\begin{calltrace}{Actualización de Estado del Horno}
\textbf{Contexto:} \texttt{MainViewModel} inicia una corrutina tras una conexión exitosa.

\begin{enumerate}
    \item \texttt{\textbf{MainViewModel}}:
    \begin{itemize}
        \item Llama a \texttt{repository.getOvenState()}.
        \item Inicia bloque \texttt{collect} (observador) sobre el flujo retornado.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{ReflowOvenRepository}}:
    \begin{itemize}
        \item Redirige la llamada a \texttt{communicationService.getOvenState()}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{WiFiService}} (Hilo: \texttt{Dispatchers.IO}):
    \begin{itemize}
        \item Entra en bucle \texttt{while (isConnected)}.
        \item \texttt{sendCommand("STATUS?\textbackslash n")}: Escribe en el Socket.
        \item \texttt{reader.nextLine()}: \textbf{Bloqueo} esperando respuesta del hardware.
        \item \textit{Parsing}: Divide la cadena recibida por delimitadores ``;''.
        \item Instancia \texttt{OvenState(temp, target, stage...)}.
        \item \texttt{emit(ovenState)}: Envía el objeto a través del flujo.
        \item \texttt{delay(1000)}: Espera no bloqueante antes del siguiente ciclo.
    \end{itemize}
    
    \item $\leftarrow$ \textit{Retorno a} \texttt{\textbf{MainViewModel}} (Hilo: \texttt{Main}):
    \begin{itemize}
        \item Recibe \texttt{OvenState}.
        \item Actualiza \texttt{\_ovenState.value} $\rightarrow$ Dispara recomposición de Textos.
        \item Llama a función interna \texttt{addGraphPoint(temp)}.
        \begin{itemize}
            \item Añade punto a \texttt{\_tempHistory}.
            \item Si \texttt{size > 120}, elimina el índice 0 (FIFO).
            \item Actualiza \texttt{\_tempHistory.value}.
        \end{itemize}
    \end{itemize}
    
    \item $\leftarrow$ \textit{Reacción en} \texttt{\textbf{DashboardScreen}}:
    \begin{itemize}
        \item \texttt{collectAsState} detecta cambio en \texttt{tempHistory}.
        \item Pasa los nuevos datos al composable \texttt{OvenChart}.
    \end{itemize}

    \item $\hookrightarrow$ \texttt{\textbf{OvenChart}}:
    \begin{itemize}
        \item Bloque \texttt{update}: Recibe los puntos nuevos.
        \item Actualiza el \texttt{LineDataSet} de la librería MPAndroidChart.
        \item Llama a \texttt{chart.notifyDataSetChanged()} e \texttt{invalidate()}.
    \end{itemize}
\end{enumerate}
\end{calltrace}

\section{Traza 2: Inyección de Perfil (Comando START)}
Proceso desencadenado cuando el usuario selecciona un perfil y pulsa "Start".

\begin{calltrace}{Envío de Perfil de Soldadura}
\textbf{Contexto:} Interacción de usuario en \texttt{DashboardScreen}.

\begin{enumerate}
    \item \texttt{\textbf{DashboardScreen}}:
    \begin{itemize}
        \item Callback \texttt{onProfileSelected}.
        \item Llama a \texttt{viewModel.startOven(reflowProfile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{MainViewModel}}:
    \begin{itemize}
        \item \texttt{launch}: Inicia nueva corrutina.
        \item Limpieza: \texttt{\_tempHistory.value = emptyList()}.
        \item Reinicio: \texttt{timeIndex = 0f}.
        \item Llama a \texttt{repository.startOven(profile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{ReflowOvenRepository}}:
    \begin{itemize}
        \item Delega a \texttt{communicationService.startOven(profile)}.
    \end{itemize}
    
    \item $\hookrightarrow$ \texttt{\textbf{WiFiService}} (Hilo: \texttt{Dispatchers.IO}):
    \begin{itemize}
        \item \textbf{Serialización}: Transforma el objeto \texttt{ReflowProfile} en cadena.
        \item Construye string: \texttt{"START;" + stage.temp + ";" + stage.time ...}
        \item Llama a \texttt{sendCommand(string)}.
        \begin{itemize}
            \item \texttt{writer.print(command)}.
            \item \texttt{writer.flush()}: Fuerza el envío del paquete TCP inmediatamente.
        \end{itemize}
    \end{itemize}
\end{enumerate}
\end{calltrace}

% ==========================================
% CAPÍTULO 4
% ==========================================
\chapter{Especificación del Protocolo de Comunicación}

El sistema utiliza un protocolo basado en texto ASCII sobre TCP/IP. La aplicación actúa como Cliente TCP y el Horno como Servidor TCP.

\section{Formato de Comandos (Cliente $\rightarrow$ Horno)}
Los comandos finalizan con un carácter de nueva línea (\texttt{\textbackslash n}).

\begin{longtable}{@{}p{4cm}p{10cm}@{}}
\toprule
\textbf{Comando} & \textbf{Descripción y Estructura} \\ \midrule
\endhead

\texttt{STATUS?} & 
Solicita el estado actual. No requiere parámetros. \\ \hline

\texttt{STOP} & 
Detiene el proceso de calentamiento inmediatamente. \\ \hline

\texttt{START;<Stages>} & 
Inicia el horno con un perfil específico. La estructura de \texttt{<Stages>} es una lista serializada de temperatura y duración. \newline
\textit{Ejemplo:} \texttt{START;Soak;150;90;Reflow;245;30} \\ \hline

\texttt{PROFILE;<Stages>} & 
Carga un perfil en memoria sin iniciar el proceso inmediatamente. Sigue la misma serialización que START. \\ 
\bottomrule
\caption{Tabla de Comandos de Control}
\end{longtable}

\section{Formato de Respuesta (Horno $\rightarrow$ Cliente)}
El horno responde al comando \texttt{STATUS?} con una cadena delimitada por punto y coma (;).

\begin{tcolorbox}[colback=codeBackground, title=Estructura de Trama STATUS]
\texttt{STATUS;CurrentTemp;TargetTemp;StageName;TimeElapsed}
\end{tcolorbox}

\textbf{Mapeo de Datos en \texttt{WiFiService.kt}:}
\begin{itemize}
    \item \texttt{parts[0]} $\rightarrow$ Cabecera ("STATUS")
    \item \texttt{parts[1]} $\rightarrow$ \texttt{currentTemperature} (Float)
    \item \texttt{parts[2]} $\rightarrow$ \texttt{targetTemperature} (Float)
    \item \texttt{parts[3]} $\rightarrow$ \texttt{stage} (String, e.g., "Soak")
    \item \texttt{parts[4]} $\rightarrow$ \texttt{timeElapsed} (Long)
\end{itemize}

% ==========================================
% CAPÍTULO 5
% ==========================================
\chapter{Gestión de Concurrencia y Memoria}

\section{Uso de Corrutinas}
Kotlin Coroutines se utiliza para evitar el bloqueo del \textit{Main Thread} (UI Thread).
\begin{itemize}
    \item \textbf{Dispatchers.IO:} Utilizado exclusivamente en \texttt{WiFiService}. Optimizado para operaciones de bloqueo de E/S como \texttt{socket.read()} o \texttt{writer.flush()}.
    \item \textbf{ViewModelScope:} Define el alcance de las corrutinas. Si el usuario cierra la aplicación o cambia de pantalla, este scope cancela automáticamente las peticiones de red pendientes, evitando \textit{memory leaks}.
\end{itemize}

\section{Optimización de Gráficos}
Dado que el horno puede operar por largos periodos, la acumulación de puntos en la gráfica representa un riesgo de consumo de memoria.
\begin{lstlisting}[language=Java, caption=Lógica de Buffer Circular en MainViewModel]
private fun addGraphPoint(temp: Float) {
    val currentList = _tempHistory.value.toMutableList()
    currentList.add(Entry(timeIndex, temp))
    timeIndex += 1f
    
    // Protección de Memoria: Ventana deslizante
    if (currentList.size > 120) {
        currentList.removeAt(0)
    }
    _tempHistory.value = ArrayList(currentList)
}
\end{lstlisting}
Esta lógica asegura que la aplicación mantenga un consumo de RAM constante (O(1)) independientemente de la duración del proceso de soldadura.

% ==========================================
% CAPÍTULO 6 (NUEVO)
% ==========================================
\chapter{Diccionario de Funciones y Lógica Operativa}

En este capítulo se desglosa la totalidad de las funciones implementadas en el sistema, detallando su lógica interna, dependencias y efectos colaterales en el flujo de ejecución.

\section{Módulo: MainViewModel (Lógica de Negocio)}

Este componente orquesta la interacción entre la UI y los datos. Todas las funciones aquí se ejecutan inicialmente en el \textit{Main Thread} pero delegan operaciones pesadas a corrutinas.

\begin{description}[style=multiline, leftmargin=3cm, font=\bfseries\color{primaryBlue}]

    \item[connect(ip, port)]
    \textbf{Propósito:} Inicia el intento de conexión con el hardware y, si tiene éxito, arranca el monitoreo.\\
    \textbf{Lógica de Llamadas:}
    \begin{enumerate}
        \item Lanza corrutina en \texttt{viewModelScope}.
        \item Invoca \texttt{repository.connect(ip, port)}.
        \item Recolecta el flujo booleano resultante.
        \item \textit{Si es True:} 
            \begin{itemize}
                \item Cancela trabajos anteriores (\texttt{ovenStateJob?.cancel}).
                \item Reinicia gráficas (\texttt{\_tempHistory = empty}).
                \item Inicia nueva corrutina interna que llama a \texttt{repository.getOvenState()} para comenzar el polling.
            \end{itemize}
        \item \textit{Si es False:} Cancela cualquier job activo.
    \end{itemize}

    \item[disconnect()]
    \textbf{Propósito:} Cierra la conexión y limpia el estado de la UI.\\
    \textbf{Lógica de Llamadas:}
    \begin{enumerate}
        \item Cancela la corrutina de monitoreo (\texttt{ovenStateJob}).
        \item Invoca \texttt{repository.disconnect()} (función suspendida).
        \item Fuerza el estado \texttt{\_isConnected} a \texttt{false}.
        \item Resetea \texttt{\_ovenState} a valores por defecto (Idle).
    \end{enumerate}

    \item[startOven(profile)]
    \textbf{Propósito:} Envía un perfil de soldadura y ordena el inicio del proceso.\\
    \textbf{Lógica de Llamadas:}
    \begin{enumerate}
        \item Limpia inmediatamente el historial gráfico (\texttt{\_tempHistory}).
        \item Resetea el contador \texttt{timeIndex} a 0.
        \item Lanza corrutina que invoca \texttt{repository.startOven(profile)}.
    \end{enumerate}

    \item[addGraphPoint(temp)]
    \textbf{Propósito:} Función auxiliar privada para gestión de memoria de la gráfica.\\
    \textbf{Lógica Interna:}
    \begin{enumerate}
        \item Clona la lista actual de puntos.
        \item Crea un nuevo objeto \texttt{Entry(x, y)}.
        \item Verifica si \texttt{lista.size > 120}. Si es cierto, ejecuta \texttt{removeAt(0)} (FIFO).
        \item Reasigna la lista al \texttt{StateFlow}, notificando a la UI.
    \end{enumerate}

\end{description}

\section{Módulo: WiFiService (Comunicación de Bajo Nivel)}

Clase encargada de la manipulación directa de Sockets y Streams. Todas las funciones operan bajo el contexto \texttt{Dispatchers.IO}.

\begin{description}[style=multiline, leftmargin=3cm, font=\bfseries\color{accentTeal}]

    \item[connect(ip, port)]
    \textbf{Propósito:} Establece el túnel TCP.\\
    \textbf{Lógica Interna:}
    \begin{enumerate}
        \item Instancia \texttt{java.net.Socket(ip, port)}.
        \item Vincula \texttt{PrintWriter} al \textit{OutputStream} (para enviar comandos).
        \item Vincula \texttt{Scanner} al \textit{InputStream} (para leer respuestas).
        \item Emite \texttt{true} si no hay excepciones; de lo contrario captura excepción y emite \texttt{false}.
    \end{enumerate}

    \item[getOvenState()]
    \textbf{Propósito:} Bucle infinito (mientras haya conexión) de petición-respuesta.\\
    \textbf{Lógica de Llamadas:}
    \begin{enumerate}
        \item Verifica \texttt{socket.isConnected}.
        \item Llama a método privado \texttt{sendCommand("STATUS?")}.
        \item Bloquea hilo esperando \texttt{reader.nextLine()}.
        \item Procesa string raw: \texttt{"STATUS;25.5;150.0;Soak;120"}.
        \item Mapea a objeto \texttt{OvenState}.
        \item \texttt{emit(state)} hacia el repositorio.
        \item \texttt{delay(1000)} para evitar saturación de red.
    \end{enumerate}

    \item[sendCommand(cmd)]
    \textbf{Propósito:} Envío físico de bytes por la red.\\
    \textbf{Lógica Interna:}
    \begin{enumerate}
        \item Verifica nulidad del \texttt{writer}.
        \item Ejecuta \texttt{writer.print(cmd)}.
        \item Ejecuta \texttt{writer.flush()} obligatoriamente para vaciar el buffer de salida del sistema operativo.
        \item Maneja posibles \texttt{IOException} logueando el error.
    \end{enumerate}
    
    \item[sendProfile(profile)]
    \textbf{Propósito:} Serialización de objeto complejo a protocolo ASCII.\\
    \textbf{Lógica Interna:}
    \begin{enumerate}
        \item Itera sobre \texttt{profile.stages}.
        \item Construye string usando \texttt{joinToString} con delimitador punto y coma.
        \item Prefija el comando "PROFILE;".
        \item Llama a \texttt{sendCommand()}.
    \end{enumerate}

\end{description}

\section{Módulo: ReflowOvenRepository (Patrón Fachada)}

Actúa como intermediario puro para aislar la implementación de red.

\begin{description}[style=multiline, leftmargin=3cm, font=\bfseries\color{primaryBlue}]

    \item[Funciones Pasarela]
    (\texttt{connect}, \texttt{disconnect}, \texttt{startOven}, etc.)\\
    \textbf{Lógica:}
    Estas funciones no contienen lógica de negocio propia. Su única función es reenviar los parámetros recibidos hacia la instancia de \texttt{CommunicationService}. Esto permite que, en el futuro, si se cambia WiFi por Bluetooth, el \texttt{ViewModel} no requiera modificaciones, solo se inyecta un servicio diferente en este repositorio.

\end{description}

\section{Módulo: DashboardScreen (Interfaz de Usuario)}

Funciones Composable que gestionan la renderización y captura de eventos.

\begin{description}[style=multiline, leftmargin=3cm, font=\bfseries\color{accentTeal}]

    \item[ConnectionDialog]
    \textbf{Propósito:} Modal para ingreso de credenciales de red.\\
    \textbf{Lógica de Eventos:}
    \begin{enumerate}
        \item Mantiene estado local temporal para IP y Puerto (\texttt{remember}).
        \item Al pulsar "Connect":
        \begin{itemize}
            \item Valida conversión de puerto a Int.
            \item Ejecuta callback \texttt{onConnect(ip, port)}.
            \item Cierra el diálogo.
        \end{itemize}
    \end{enumerate}

    \item[CustomProfileDialog]
    \textbf{Propósito:} Formulario para creación de perfiles ad-hoc.\\
    \textbf{Lógica Interna:}
    \begin{enumerate}
        \item Captura 5 campos de texto (Nombre, Temp Soak, Tiempo Soak, Temp Reflow, Tiempo Reflow).
        \item Al confirmar, instancia un nuevo objeto \texttt{ReflowProfile}.
        \item Devuelve el objeto creado al padre mediante \texttt{onProfileCreated(it)}.
    \end{enumerate}

    \item[OvenChart (Update Block)]
    \textbf{Propósito:} Actualización reactiva de la vista de Android clásica.\\
    \textbf{Lógica de Llamadas:}
    \begin{enumerate}
        \item Se ejecuta cada vez que cambia la lista \texttt{points}.
        \item Si la lista no está vacía:
        \begin{itemize}
            \item Obtiene referencia al \texttt{LineDataSet} existente.
            \item Inyecta la nueva lista de puntos.
            \item Notifica cambios a la librería gráfica para forzar el repintado (\texttt{invalidate}).
        \end{itemize}
        \item Si la lista está vacía, limpia el gráfico (\texttt{chart.clear}).
    \end{enumerate}

\end{description}


\chapter{Conclusión}
La arquitectura presentada desacopla exitosamente la lógica de control crítica (WiFi/TCP) de la interfaz de usuario moderna (Compose). La distribución de llamadas demuestra un flujo de datos unidireccional (UDF), donde los eventos fluyen hacia arriba (UI $\rightarrow$ ViewModel $\rightarrow$ Repositorio) y los datos fluyen hacia abajo mediante flujos reactivos, resultando en un sistema robusto, mantenible y profesional.

\end{document}
